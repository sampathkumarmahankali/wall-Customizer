"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-rnd";
exports.ids = ["vendor-chunks/react-rnd"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-rnd/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/react-rnd/lib/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rnd: () => (/* binding */ Rnd)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-draggable */ \"(ssr)/./node_modules/react-draggable/build/cjs/cjs.js\");\n/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_draggable__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var re_resizable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! re-resizable */ \"(ssr)/./node_modules/re-resizable/lib/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nvar resizableStyle = {\n    width: \"auto\",\n    height: \"auto\",\n    display: \"inline-block\",\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n};\nvar getEnableResizingByFlag = function (flag) { return ({\n    bottom: flag,\n    bottomLeft: flag,\n    bottomRight: flag,\n    left: flag,\n    right: flag,\n    top: flag,\n    topLeft: flag,\n    topRight: flag,\n}); };\nvar Rnd = /** @class */ (function (_super) {\n    __extends(Rnd, _super);\n    function Rnd(props) {\n        var _this = _super.call(this, props) || this;\n        _this.resizingPosition = { x: 0, y: 0 };\n        _this.offsetFromParent = { left: 0, top: 0 };\n        _this.resizableElement = { current: null };\n        _this.originalPosition = { x: 0, y: 0 };\n        _this.state = {\n            resizing: false,\n            bounds: {\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 0,\n            },\n            maxWidth: props.maxWidth,\n            maxHeight: props.maxHeight,\n        };\n        _this.onResizeStart = _this.onResizeStart.bind(_this);\n        _this.onResize = _this.onResize.bind(_this);\n        _this.onResizeStop = _this.onResizeStop.bind(_this);\n        _this.onDragStart = _this.onDragStart.bind(_this);\n        _this.onDrag = _this.onDrag.bind(_this);\n        _this.onDragStop = _this.onDragStop.bind(_this);\n        _this.getMaxSizesFromProps = _this.getMaxSizesFromProps.bind(_this);\n        return _this;\n    }\n    Rnd.prototype.componentDidMount = function () {\n        this.updateOffsetFromParent();\n        var _a = this.offsetFromParent, left = _a.left, top = _a.top;\n        var _b = this.getDraggablePosition(), x = _b.x, y = _b.y;\n        this.draggable.setState({\n            x: x - left,\n            y: y - top,\n        });\n        // HACK: Apply position adjustment\n        this.forceUpdate();\n    };\n    // HACK: To get `react-draggable` state x and y.\n    Rnd.prototype.getDraggablePosition = function () {\n        var _a = this.draggable.state, x = _a.x, y = _a.y;\n        return { x: x, y: y };\n    };\n    Rnd.prototype.getParent = function () {\n        return this.resizable && this.resizable.parentNode;\n    };\n    Rnd.prototype.getParentSize = function () {\n        return this.resizable.getParentSize();\n    };\n    Rnd.prototype.getMaxSizesFromProps = function () {\n        var maxWidth = typeof this.props.maxWidth === \"undefined\" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth;\n        var maxHeight = typeof this.props.maxHeight === \"undefined\" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;\n        return { maxWidth: maxWidth, maxHeight: maxHeight };\n    };\n    Rnd.prototype.getSelfElement = function () {\n        return this.resizable && this.resizable.resizable;\n    };\n    Rnd.prototype.getOffsetHeight = function (boundary) {\n        var scale = this.props.scale;\n        switch (this.props.bounds) {\n            case \"window\":\n                return window.innerHeight / scale;\n            case \"body\":\n                return document.body.offsetHeight / scale;\n            default:\n                return boundary.offsetHeight;\n        }\n    };\n    Rnd.prototype.getOffsetWidth = function (boundary) {\n        var scale = this.props.scale;\n        switch (this.props.bounds) {\n            case \"window\":\n                return window.innerWidth / scale;\n            case \"body\":\n                return document.body.offsetWidth / scale;\n            default:\n                return boundary.offsetWidth;\n        }\n    };\n    Rnd.prototype.onDragStart = function (e, data) {\n        if (this.props.onDragStart) {\n            this.props.onDragStart(e, data);\n        }\n        var pos = this.getDraggablePosition();\n        this.originalPosition = pos;\n        if (!this.props.bounds)\n            return;\n        var parent = this.getParent();\n        var scale = this.props.scale;\n        var boundary;\n        if (this.props.bounds === \"parent\") {\n            boundary = parent;\n        }\n        else if (this.props.bounds === \"body\") {\n            var parentRect_1 = parent.getBoundingClientRect();\n            var parentLeft_1 = parentRect_1.left;\n            var parentTop_1 = parentRect_1.top;\n            var bodyRect = document.body.getBoundingClientRect();\n            var left_1 = -(parentLeft_1 - parent.offsetLeft * scale - bodyRect.left) / scale;\n            var top_1 = -(parentTop_1 - parent.offsetTop * scale - bodyRect.top) / scale;\n            var right = (document.body.offsetWidth - this.resizable.size.width * scale) / scale + left_1;\n            var bottom = (document.body.offsetHeight - this.resizable.size.height * scale) / scale + top_1;\n            return this.setState({ bounds: { top: top_1, right: right, bottom: bottom, left: left_1 } });\n        }\n        else if (this.props.bounds === \"window\") {\n            if (!this.resizable)\n                return;\n            var parentRect_2 = parent.getBoundingClientRect();\n            var parentLeft_2 = parentRect_2.left;\n            var parentTop_2 = parentRect_2.top;\n            var left_2 = -(parentLeft_2 - parent.offsetLeft * scale) / scale;\n            var top_2 = -(parentTop_2 - parent.offsetTop * scale) / scale;\n            var right = (window.innerWidth - this.resizable.size.width * scale) / scale + left_2;\n            var bottom = (window.innerHeight - this.resizable.size.height * scale) / scale + top_2;\n            return this.setState({ bounds: { top: top_2, right: right, bottom: bottom, left: left_2 } });\n        }\n        else if (typeof this.props.bounds === \"string\") {\n            boundary = document.querySelector(this.props.bounds);\n        }\n        else if (this.props.bounds instanceof HTMLElement) {\n            boundary = this.props.bounds;\n        }\n        if (!(boundary instanceof HTMLElement) || !(parent instanceof HTMLElement)) {\n            return;\n        }\n        var boundaryRect = boundary.getBoundingClientRect();\n        var boundaryLeft = boundaryRect.left;\n        var boundaryTop = boundaryRect.top;\n        var parentRect = parent.getBoundingClientRect();\n        var parentLeft = parentRect.left;\n        var parentTop = parentRect.top;\n        var left = (boundaryLeft - parentLeft) / scale;\n        var top = boundaryTop - parentTop;\n        if (!this.resizable)\n            return;\n        this.updateOffsetFromParent();\n        var offset = this.offsetFromParent;\n        this.setState({\n            bounds: {\n                top: top - offset.top,\n                right: left + (boundary.offsetWidth - this.resizable.size.width) - offset.left / scale,\n                bottom: top + (boundary.offsetHeight - this.resizable.size.height) - offset.top,\n                left: left - offset.left / scale,\n            },\n        });\n    };\n    Rnd.prototype.onDrag = function (e, data) {\n        if (!this.props.onDrag)\n            return;\n        var _a = this.offsetFromParent, left = _a.left, top = _a.top;\n        if (!this.props.dragAxis || this.props.dragAxis === \"both\") {\n            return this.props.onDrag(e, __assign(__assign({}, data), { x: data.x + left, y: data.y + top }));\n        }\n        else if (this.props.dragAxis === \"x\") {\n            return this.props.onDrag(e, __assign(__assign({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));\n        }\n        else if (this.props.dragAxis === \"y\") {\n            return this.props.onDrag(e, __assign(__assign({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));\n        }\n    };\n    Rnd.prototype.onDragStop = function (e, data) {\n        if (!this.props.onDragStop)\n            return;\n        var _a = this.offsetFromParent, left = _a.left, top = _a.top;\n        if (!this.props.dragAxis || this.props.dragAxis === \"both\") {\n            return this.props.onDragStop(e, __assign(__assign({}, data), { x: data.x + left, y: data.y + top }));\n        }\n        else if (this.props.dragAxis === \"x\") {\n            return this.props.onDragStop(e, __assign(__assign({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));\n        }\n        else if (this.props.dragAxis === \"y\") {\n            return this.props.onDragStop(e, __assign(__assign({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));\n        }\n    };\n    Rnd.prototype.onResizeStart = function (e, dir, elementRef) {\n        e.stopPropagation();\n        this.setState({\n            resizing: true,\n        });\n        var scale = this.props.scale;\n        var offset = this.offsetFromParent;\n        var pos = this.getDraggablePosition();\n        this.resizingPosition = { x: pos.x + offset.left, y: pos.y + offset.top };\n        this.originalPosition = pos;\n        if (this.props.bounds) {\n            var parent_1 = this.getParent();\n            var boundary = void 0;\n            if (this.props.bounds === \"parent\") {\n                boundary = parent_1;\n            }\n            else if (this.props.bounds === \"body\") {\n                boundary = document.body;\n            }\n            else if (this.props.bounds === \"window\") {\n                boundary = window;\n            }\n            else if (typeof this.props.bounds === \"string\") {\n                boundary = document.querySelector(this.props.bounds);\n            }\n            else if (this.props.bounds instanceof HTMLElement) {\n                boundary = this.props.bounds;\n            }\n            var self_1 = this.getSelfElement();\n            if (self_1 instanceof Element &&\n                (boundary instanceof HTMLElement || boundary === window) &&\n                parent_1 instanceof HTMLElement) {\n                var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;\n                var parentSize = this.getParentSize();\n                if (maxWidth && typeof maxWidth === \"string\") {\n                    if (maxWidth.endsWith(\"%\")) {\n                        var ratio = Number(maxWidth.replace(\"%\", \"\")) / 100;\n                        maxWidth = parentSize.width * ratio;\n                    }\n                    else if (maxWidth.endsWith(\"px\")) {\n                        maxWidth = Number(maxWidth.replace(\"px\", \"\"));\n                    }\n                }\n                if (maxHeight && typeof maxHeight === \"string\") {\n                    if (maxHeight.endsWith(\"%\")) {\n                        var ratio = Number(maxHeight.replace(\"%\", \"\")) / 100;\n                        maxHeight = parentSize.height * ratio;\n                    }\n                    else if (maxHeight.endsWith(\"px\")) {\n                        maxHeight = Number(maxHeight.replace(\"px\", \"\"));\n                    }\n                }\n                var selfRect = self_1.getBoundingClientRect();\n                var selfLeft = selfRect.left;\n                var selfTop = selfRect.top;\n                var boundaryRect = this.props.bounds === \"window\" ? { left: 0, top: 0 } : boundary.getBoundingClientRect();\n                var boundaryLeft = boundaryRect.left;\n                var boundaryTop = boundaryRect.top;\n                var offsetWidth = this.getOffsetWidth(boundary);\n                var offsetHeight = this.getOffsetHeight(boundary);\n                var hasLeft = dir.toLowerCase().endsWith(\"left\");\n                var hasRight = dir.toLowerCase().endsWith(\"right\");\n                var hasTop = dir.startsWith(\"top\");\n                var hasBottom = dir.startsWith(\"bottom\");\n                if ((hasLeft || hasTop) && this.resizable) {\n                    var max = (selfLeft - boundaryLeft) / scale + this.resizable.size.width;\n                    this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });\n                }\n                // INFO: To set bounds in `lock aspect ratio with bounds` case. See also that story.\n                if (hasRight || (this.props.lockAspectRatio && !hasLeft && !hasTop)) {\n                    var max = offsetWidth + (boundaryLeft - selfLeft) / scale;\n                    this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });\n                }\n                if ((hasTop || hasLeft) && this.resizable) {\n                    var max = (selfTop - boundaryTop) / scale + this.resizable.size.height;\n                    this.setState({\n                        maxHeight: max > Number(maxHeight) ? maxHeight : max,\n                    });\n                }\n                // INFO: To set bounds in `lock aspect ratio with bounds` case. See also that story.\n                if (hasBottom || (this.props.lockAspectRatio && !hasTop && !hasLeft)) {\n                    var max = offsetHeight + (boundaryTop - selfTop) / scale;\n                    this.setState({\n                        maxHeight: max > Number(maxHeight) ? maxHeight : max,\n                    });\n                }\n            }\n        }\n        else {\n            this.setState({\n                maxWidth: this.props.maxWidth,\n                maxHeight: this.props.maxHeight,\n            });\n        }\n        if (this.props.onResizeStart) {\n            this.props.onResizeStart(e, dir, elementRef);\n        }\n    };\n    Rnd.prototype.onResize = function (e, direction, elementRef, delta) {\n        var _this = this;\n        // INFO: Apply x and y position adjustments caused by resizing to draggable\n        var newPos = { x: this.originalPosition.x, y: this.originalPosition.y };\n        var left = -delta.width;\n        var top = -delta.height;\n        var directions = [\"top\", \"left\", \"topLeft\", \"bottomLeft\", \"topRight\"];\n        if (directions.includes(direction)) {\n            if (direction === \"bottomLeft\") {\n                newPos.x += left;\n            }\n            else if (direction === \"topRight\") {\n                newPos.y += top;\n            }\n            else {\n                newPos.x += left;\n                newPos.y += top;\n            }\n        }\n        var draggableState = this.draggable.state;\n        if (newPos.x !== draggableState.x || newPos.y !== draggableState.y) {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync)(function () {\n                _this.draggable.setState(newPos);\n            });\n        }\n        this.updateOffsetFromParent();\n        var offset = this.offsetFromParent;\n        var x = this.getDraggablePosition().x + offset.left;\n        var y = this.getDraggablePosition().y + offset.top;\n        this.resizingPosition = { x: x, y: y };\n        if (!this.props.onResize)\n            return;\n        this.props.onResize(e, direction, elementRef, delta, {\n            x: x,\n            y: y,\n        });\n    };\n    Rnd.prototype.onResizeStop = function (e, direction, elementRef, delta) {\n        this.setState({\n            resizing: false,\n        });\n        var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;\n        this.setState({ maxWidth: maxWidth, maxHeight: maxHeight });\n        if (this.props.onResizeStop) {\n            this.props.onResizeStop(e, direction, elementRef, delta, this.resizingPosition);\n        }\n    };\n    Rnd.prototype.updateSize = function (size) {\n        if (!this.resizable)\n            return;\n        this.resizable.updateSize({ width: size.width, height: size.height });\n    };\n    Rnd.prototype.updatePosition = function (position) {\n        this.draggable.setState(position);\n    };\n    Rnd.prototype.updateOffsetFromParent = function () {\n        var scale = this.props.scale;\n        var parent = this.getParent();\n        var self = this.getSelfElement();\n        if (!parent || self === null) {\n            return {\n                top: 0,\n                left: 0,\n            };\n        }\n        var parentRect = parent.getBoundingClientRect();\n        var parentLeft = parentRect.left;\n        var parentTop = parentRect.top;\n        var selfRect = self.getBoundingClientRect();\n        var position = this.getDraggablePosition();\n        var scrollLeft = parent.scrollLeft;\n        var scrollTop = parent.scrollTop;\n        this.offsetFromParent = {\n            left: selfRect.left - parentLeft + scrollLeft - position.x * scale,\n            top: selfRect.top - parentTop + scrollTop - position.y * scale,\n        };\n    };\n    Rnd.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, disableDragging = _a.disableDragging, style = _a.style, dragHandleClassName = _a.dragHandleClassName, position = _a.position, onMouseDown = _a.onMouseDown, onMouseUp = _a.onMouseUp, dragAxis = _a.dragAxis, dragGrid = _a.dragGrid, bounds = _a.bounds, enableUserSelectHack = _a.enableUserSelectHack, cancel = _a.cancel, children = _a.children, onResizeStart = _a.onResizeStart, onResize = _a.onResize, onResizeStop = _a.onResizeStop, onDragStart = _a.onDragStart, onDrag = _a.onDrag, onDragStop = _a.onDragStop, resizeHandleStyles = _a.resizeHandleStyles, resizeHandleClasses = _a.resizeHandleClasses, resizeHandleComponent = _a.resizeHandleComponent, enableResizing = _a.enableResizing, resizeGrid = _a.resizeGrid, resizeHandleWrapperClass = _a.resizeHandleWrapperClass, resizeHandleWrapperStyle = _a.resizeHandleWrapperStyle, scale = _a.scale, allowAnyClick = _a.allowAnyClick, dragPositionOffset = _a.dragPositionOffset, resizableProps = __rest(_a, [\"disableDragging\", \"style\", \"dragHandleClassName\", \"position\", \"onMouseDown\", \"onMouseUp\", \"dragAxis\", \"dragGrid\", \"bounds\", \"enableUserSelectHack\", \"cancel\", \"children\", \"onResizeStart\", \"onResize\", \"onResizeStop\", \"onDragStart\", \"onDrag\", \"onDragStop\", \"resizeHandleStyles\", \"resizeHandleClasses\", \"resizeHandleComponent\", \"enableResizing\", \"resizeGrid\", \"resizeHandleWrapperClass\", \"resizeHandleWrapperStyle\", \"scale\", \"allowAnyClick\", \"dragPositionOffset\"]);\n        var defaultValue = this.props.default ? __assign({}, this.props.default) : undefined;\n        // Remove unknown props, see also https://reactjs.org/warnings/unknown-prop.html\n        delete resizableProps.default;\n        var cursorStyle = disableDragging || dragHandleClassName ? { cursor: \"auto\" } : { cursor: \"move\" };\n        var innerStyle = __assign(__assign(__assign({}, resizableStyle), cursorStyle), style);\n        var _b = this.offsetFromParent, left = _b.left, top = _b.top;\n        var draggablePosition;\n        if (position) {\n            draggablePosition = {\n                x: position.x - left,\n                y: position.y - top,\n            };\n        }\n        // INFO: Make uncontorolled component when resizing to control position by setPostion.\n        var pos = this.state.resizing ? undefined : draggablePosition;\n        var dragAxisOrUndefined = this.state.resizing ? \"both\" : dragAxis;\n        return ((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)((react_draggable__WEBPACK_IMPORTED_MODULE_1___default()), { ref: function (c) {\n                if (!c)\n                    return;\n                _this.draggable = c;\n            }, handle: dragHandleClassName ? \".\".concat(dragHandleClassName) : undefined, defaultPosition: defaultValue, onMouseDown: onMouseDown, \n            // @ts-expect-error\n            onMouseUp: onMouseUp, onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop, axis: dragAxisOrUndefined, disabled: disableDragging, grid: dragGrid, bounds: bounds ? this.state.bounds : undefined, position: pos, enableUserSelectHack: enableUserSelectHack, cancel: cancel, scale: scale, allowAnyClick: allowAnyClick, nodeRef: this.resizableElement, positionOffset: dragPositionOffset },\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(re_resizable__WEBPACK_IMPORTED_MODULE_2__.Resizable, __assign({}, resizableProps, { ref: function (c) {\n                    if (!c)\n                        return;\n                    _this.resizable = c;\n                    _this.resizableElement.current = c.resizable;\n                }, defaultSize: defaultValue, size: this.props.size, enable: typeof enableResizing === \"boolean\" ? getEnableResizingByFlag(enableResizing) : enableResizing, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: innerStyle, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: resizeGrid, handleWrapperClass: resizeHandleWrapperClass, handleWrapperStyle: resizeHandleWrapperStyle, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: resizeHandleStyles, handleClasses: resizeHandleClasses, handleComponent: resizeHandleComponent, scale: this.props.scale }), children)));\n    };\n    Rnd.defaultProps = {\n        maxWidth: Number.MAX_SAFE_INTEGER,\n        maxHeight: Number.MAX_SAFE_INTEGER,\n        scale: 1,\n        onResizeStart: function () { },\n        onResize: function () { },\n        onResizeStop: function () { },\n        onDragStart: function () { },\n        onDrag: function () { },\n        onDragStop: function () { },\n    };\n    return Rnd;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm5kL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFxRDtBQUNiO0FBQ0M7QUFDSDs7QUFFdEM7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLDBEQUEwRDtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVUsMERBQTBEO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVyxtQ0FBbUM7QUFDMUc7QUFDQTtBQUNBLDREQUE0RCxXQUFXLCtEQUErRDtBQUN0STtBQUNBO0FBQ0EsNERBQTRELFdBQVcsK0RBQStEO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVcsbUNBQW1DO0FBQzlHO0FBQ0E7QUFDQSxnRUFBZ0UsV0FBVywrREFBK0Q7QUFDMUk7QUFDQTtBQUNBLGdFQUFnRSxXQUFXLCtEQUErRDtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBbUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQVM7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EscUVBQXFFLGlCQUFpQixJQUFJO0FBQzFGLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFhLENBQUMsd0RBQVMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0WkFBNFo7QUFDNVosWUFBWSxvREFBYSxDQUFDLG1EQUFTLGFBQWEsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDI0QkFBMjRCO0FBQzU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLGlDQUFpQztBQUNqQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLENBQUMsQ0FBQyxnREFBYTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXByb2plY3QvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm5kL2xpYi9pbmRleC5qcz83YTQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJ3JlYWN0LWRyYWdnYWJsZSc7XG5pbXBvcnQgeyBSZXNpemFibGUgfSBmcm9tICdyZS1yZXNpemFibGUnO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSAncmVhY3QtZG9tJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG52YXIgcmVzaXphYmxlU3R5bGUgPSB7XG4gICAgd2lkdGg6IFwiYXV0b1wiLFxuICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxufTtcbnZhciBnZXRFbmFibGVSZXNpemluZ0J5RmxhZyA9IGZ1bmN0aW9uIChmbGFnKSB7IHJldHVybiAoe1xuICAgIGJvdHRvbTogZmxhZyxcbiAgICBib3R0b21MZWZ0OiBmbGFnLFxuICAgIGJvdHRvbVJpZ2h0OiBmbGFnLFxuICAgIGxlZnQ6IGZsYWcsXG4gICAgcmlnaHQ6IGZsYWcsXG4gICAgdG9wOiBmbGFnLFxuICAgIHRvcExlZnQ6IGZsYWcsXG4gICAgdG9wUmlnaHQ6IGZsYWcsXG59KTsgfTtcbnZhciBSbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJuZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSbmQocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlc2l6aW5nUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgX3RoaXMub2Zmc2V0RnJvbVBhcmVudCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIF90aGlzLnJlc2l6YWJsZUVsZW1lbnQgPSB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgICAgICAgX3RoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhXaWR0aDogcHJvcHMubWF4V2lkdGgsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IHByb3BzLm1heEhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25SZXNpemVTdGFydCA9IF90aGlzLm9uUmVzaXplU3RhcnQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uUmVzaXplID0gX3RoaXMub25SZXNpemUuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uUmVzaXplU3RvcCA9IF90aGlzLm9uUmVzaXplU3RvcC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMub25EcmFnU3RhcnQgPSBfdGhpcy5vbkRyYWdTdGFydC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMub25EcmFnID0gX3RoaXMub25EcmFnLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5vbkRyYWdTdG9wID0gX3RoaXMub25EcmFnU3RvcC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuZ2V0TWF4U2l6ZXNGcm9tUHJvcHMgPSBfdGhpcy5nZXRNYXhTaXplc0Zyb21Qcm9wcy5iaW5kKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSbmQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU9mZnNldEZyb21QYXJlbnQoKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vZmZzZXRGcm9tUGFyZW50LCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLmdldERyYWdnYWJsZVBvc2l0aW9uKCksIHggPSBfYi54LCB5ID0gX2IueTtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgeDogeCAtIGxlZnQsXG4gICAgICAgICAgICB5OiB5IC0gdG9wLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSEFDSzogQXBwbHkgcG9zaXRpb24gYWRqdXN0bWVudFxuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfTtcbiAgICAvLyBIQUNLOiBUbyBnZXQgYHJlYWN0LWRyYWdnYWJsZWAgc3RhdGUgeCBhbmQgeS5cbiAgICBSbmQucHJvdG90eXBlLmdldERyYWdnYWJsZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmRyYWdnYWJsZS5zdGF0ZSwgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXphYmxlICYmIHRoaXMucmVzaXphYmxlLnBhcmVudE5vZGU7XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLmdldFBhcmVudFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6YWJsZS5nZXRQYXJlbnRTaXplKCk7XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLmdldE1heFNpemVzRnJvbVByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4V2lkdGggPSB0eXBlb2YgdGhpcy5wcm9wcy5tYXhXaWR0aCA9PT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGhpcy5wcm9wcy5tYXhXaWR0aDtcbiAgICAgICAgdmFyIG1heEhlaWdodCA9IHR5cGVvZiB0aGlzLnByb3BzLm1heEhlaWdodCA9PT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGhpcy5wcm9wcy5tYXhIZWlnaHQ7XG4gICAgICAgIHJldHVybiB7IG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfTtcbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUuZ2V0U2VsZkVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6YWJsZSAmJiB0aGlzLnJlc2l6YWJsZS5yZXNpemFibGU7XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLmdldE9mZnNldEhlaWdodCA9IGZ1bmN0aW9uIChib3VuZGFyeSkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnByb3BzLnNjYWxlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucHJvcHMuYm91bmRzKSB7XG4gICAgICAgICAgICBjYXNlIFwid2luZG93XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCAvIHNjYWxlO1xuICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQgLyBzY2FsZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvdW5kYXJ5Lm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5nZXRPZmZzZXRXaWR0aCA9IGZ1bmN0aW9uIChib3VuZGFyeSkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnByb3BzLnNjYWxlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucHJvcHMuYm91bmRzKSB7XG4gICAgICAgICAgICBjYXNlIFwid2luZG93XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIC8gc2NhbGU7XG4gICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoIC8gc2NhbGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBib3VuZGFyeS5vZmZzZXRXaWR0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0KGUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmdldERyYWdnYWJsZVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHBvcztcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmJvdW5kcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMucHJvcHMuc2NhbGU7XG4gICAgICAgIHZhciBib3VuZGFyeTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSBcInBhcmVudFwiKSB7XG4gICAgICAgICAgICBib3VuZGFyeSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJib2R5XCIpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRSZWN0XzEgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50TGVmdF8xID0gcGFyZW50UmVjdF8xLmxlZnQ7XG4gICAgICAgICAgICB2YXIgcGFyZW50VG9wXzEgPSBwYXJlbnRSZWN0XzEudG9wO1xuICAgICAgICAgICAgdmFyIGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBsZWZ0XzEgPSAtKHBhcmVudExlZnRfMSAtIHBhcmVudC5vZmZzZXRMZWZ0ICogc2NhbGUgLSBib2R5UmVjdC5sZWZ0KSAvIHNjYWxlO1xuICAgICAgICAgICAgdmFyIHRvcF8xID0gLShwYXJlbnRUb3BfMSAtIHBhcmVudC5vZmZzZXRUb3AgKiBzY2FsZSAtIGJvZHlSZWN0LnRvcCkgLyBzY2FsZTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IChkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoIC0gdGhpcy5yZXNpemFibGUuc2l6ZS53aWR0aCAqIHNjYWxlKSAvIHNjYWxlICsgbGVmdF8xO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IChkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCAtIHRoaXMucmVzaXphYmxlLnNpemUuaGVpZ2h0ICogc2NhbGUpIC8gc2NhbGUgKyB0b3BfMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHsgYm91bmRzOiB7IHRvcDogdG9wXzEsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20sIGxlZnQ6IGxlZnRfMSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSBcIndpbmRvd1wiKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBwYXJlbnRSZWN0XzIgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50TGVmdF8yID0gcGFyZW50UmVjdF8yLmxlZnQ7XG4gICAgICAgICAgICB2YXIgcGFyZW50VG9wXzIgPSBwYXJlbnRSZWN0XzIudG9wO1xuICAgICAgICAgICAgdmFyIGxlZnRfMiA9IC0ocGFyZW50TGVmdF8yIC0gcGFyZW50Lm9mZnNldExlZnQgKiBzY2FsZSkgLyBzY2FsZTtcbiAgICAgICAgICAgIHZhciB0b3BfMiA9IC0ocGFyZW50VG9wXzIgLSBwYXJlbnQub2Zmc2V0VG9wICogc2NhbGUpIC8gc2NhbGU7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSAod2luZG93LmlubmVyV2lkdGggLSB0aGlzLnJlc2l6YWJsZS5zaXplLndpZHRoICogc2NhbGUpIC8gc2NhbGUgKyBsZWZ0XzI7XG4gICAgICAgICAgICB2YXIgYm90dG9tID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIHRoaXMucmVzaXphYmxlLnNpemUuaGVpZ2h0ICogc2NhbGUpIC8gc2NhbGUgKyB0b3BfMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHsgYm91bmRzOiB7IHRvcDogdG9wXzIsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20sIGxlZnQ6IGxlZnRfMiB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYm91bmRhcnkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMucHJvcHMuYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBib3VuZGFyeSA9IHRoaXMucHJvcHMuYm91bmRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGJvdW5kYXJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8ICEocGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kYXJ5UmVjdCA9IGJvdW5kYXJ5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgYm91bmRhcnlMZWZ0ID0gYm91bmRhcnlSZWN0LmxlZnQ7XG4gICAgICAgIHZhciBib3VuZGFyeVRvcCA9IGJvdW5kYXJ5UmVjdC50b3A7XG4gICAgICAgIHZhciBwYXJlbnRSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcGFyZW50TGVmdCA9IHBhcmVudFJlY3QubGVmdDtcbiAgICAgICAgdmFyIHBhcmVudFRvcCA9IHBhcmVudFJlY3QudG9wO1xuICAgICAgICB2YXIgbGVmdCA9IChib3VuZGFyeUxlZnQgLSBwYXJlbnRMZWZ0KSAvIHNjYWxlO1xuICAgICAgICB2YXIgdG9wID0gYm91bmRhcnlUb3AgLSBwYXJlbnRUb3A7XG4gICAgICAgIGlmICghdGhpcy5yZXNpemFibGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudXBkYXRlT2Zmc2V0RnJvbVBhcmVudCgpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXRGcm9tUGFyZW50O1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wIC0gb2Zmc2V0LnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogbGVmdCArIChib3VuZGFyeS5vZmZzZXRXaWR0aCAtIHRoaXMucmVzaXphYmxlLnNpemUud2lkdGgpIC0gb2Zmc2V0LmxlZnQgLyBzY2FsZSxcbiAgICAgICAgICAgICAgICBib3R0b206IHRvcCArIChib3VuZGFyeS5vZmZzZXRIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodCkgLSBvZmZzZXQudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQgLSBvZmZzZXQubGVmdCAvIHNjYWxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLm9uRHJhZyA9IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5vbkRyYWcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBfYSA9IHRoaXMub2Zmc2V0RnJvbVBhcmVudCwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcDtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmRyYWdBeGlzIHx8IHRoaXMucHJvcHMuZHJhZ0F4aXMgPT09IFwiYm90aFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkRyYWcoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IGRhdGEueCArIGxlZnQsIHk6IGRhdGEueSArIHRvcCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5kcmFnQXhpcyA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uRHJhZyhlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgeDogZGF0YS54ICsgbGVmdCwgeTogdGhpcy5vcmlnaW5hbFBvc2l0aW9uLnkgKyB0b3AsIGRlbHRhWTogMCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5kcmFnQXhpcyA9PT0gXCJ5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uRHJhZyhlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgeDogdGhpcy5vcmlnaW5hbFBvc2l0aW9uLnggKyBsZWZ0LCB5OiBkYXRhLnkgKyB0b3AsIGRlbHRhWDogMCB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUub25EcmFnU3RvcCA9IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5vbkRyYWdTdG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9mZnNldEZyb21QYXJlbnQsIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3A7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5kcmFnQXhpcyB8fCB0aGlzLnByb3BzLmRyYWdBeGlzID09PSBcImJvdGhcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25EcmFnU3RvcChlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgeDogZGF0YS54ICsgbGVmdCwgeTogZGF0YS55ICsgdG9wIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmRyYWdBeGlzID09PSBcInhcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25EcmFnU3RvcChlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgeDogZGF0YS54ICsgbGVmdCwgeTogdGhpcy5vcmlnaW5hbFBvc2l0aW9uLnkgKyB0b3AsIGRlbHRhWTogMCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5kcmFnQXhpcyA9PT0gXCJ5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi54ICsgbGVmdCwgeTogZGF0YS55ICsgdG9wLCBkZWx0YVg6IDAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLm9uUmVzaXplU3RhcnQgPSBmdW5jdGlvbiAoZSwgZGlyLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcmVzaXppbmc6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnByb3BzLnNjYWxlO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXRGcm9tUGFyZW50O1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLnJlc2l6aW5nUG9zaXRpb24gPSB7IHg6IHBvcy54ICsgb2Zmc2V0LmxlZnQsIHk6IHBvcy55ICsgb2Zmc2V0LnRvcCB9O1xuICAgICAgICB0aGlzLm9yaWdpbmFsUG9zaXRpb24gPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmJvdW5kcykge1xuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIHZhciBib3VuZGFyeSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJwYXJlbnRcIikge1xuICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gcGFyZW50XzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJib2R5XCIpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJ3aW5kb3dcIikge1xuICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gd2luZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMucHJvcHMuYm91bmRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYm91bmRhcnkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMucHJvcHMuYm91bmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuYm91bmRzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IHRoaXMucHJvcHMuYm91bmRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGZfMSA9IHRoaXMuZ2V0U2VsZkVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChzZWxmXzEgaW5zdGFuY2VvZiBFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgKGJvdW5kYXJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgYm91bmRhcnkgPT09IHdpbmRvdykgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnRfMSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRNYXhTaXplc0Zyb21Qcm9wcygpLCBtYXhXaWR0aCA9IF9hLm1heFdpZHRoLCBtYXhIZWlnaHQgPSBfYS5tYXhIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFNpemUgPSB0aGlzLmdldFBhcmVudFNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4V2lkdGggJiYgdHlwZW9mIG1heFdpZHRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhXaWR0aC5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IE51bWJlcihtYXhXaWR0aC5yZXBsYWNlKFwiJVwiLCBcIlwiKSkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IHBhcmVudFNpemUud2lkdGggKiByYXRpbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXhXaWR0aC5lbmRzV2l0aChcInB4XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE51bWJlcihtYXhXaWR0aC5yZXBsYWNlKFwicHhcIiwgXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXhIZWlnaHQgJiYgdHlwZW9mIG1heEhlaWdodCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4SGVpZ2h0LmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gTnVtYmVyKG1heEhlaWdodC5yZXBsYWNlKFwiJVwiLCBcIlwiKSkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBwYXJlbnRTaXplLmhlaWdodCAqIHJhdGlvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heEhlaWdodC5lbmRzV2l0aChcInB4XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBOdW1iZXIobWF4SGVpZ2h0LnJlcGxhY2UoXCJweFwiLCBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNlbGZSZWN0ID0gc2VsZl8xLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxmTGVmdCA9IHNlbGZSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGZUb3AgPSBzZWxmUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5UmVjdCA9IHRoaXMucHJvcHMuYm91bmRzID09PSBcIndpbmRvd1wiID8geyBsZWZ0OiAwLCB0b3A6IDAgfSA6IGJvdW5kYXJ5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGFyeUxlZnQgPSBib3VuZGFyeVJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnlUb3AgPSBib3VuZGFyeVJlY3QudG9wO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRXaWR0aCA9IHRoaXMuZ2V0T2Zmc2V0V2lkdGgoYm91bmRhcnkpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRIZWlnaHQgPSB0aGlzLmdldE9mZnNldEhlaWdodChib3VuZGFyeSk7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0xlZnQgPSBkaXIudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcImxlZnRcIik7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1JpZ2h0ID0gZGlyLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoXCJyaWdodFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzVG9wID0gZGlyLnN0YXJ0c1dpdGgoXCJ0b3BcIik7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0JvdHRvbSA9IGRpci5zdGFydHNXaXRoKFwiYm90dG9tXCIpO1xuICAgICAgICAgICAgICAgIGlmICgoaGFzTGVmdCB8fCBoYXNUb3ApICYmIHRoaXMucmVzaXphYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSAoc2VsZkxlZnQgLSBib3VuZGFyeUxlZnQpIC8gc2NhbGUgKyB0aGlzLnJlc2l6YWJsZS5zaXplLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgbWF4V2lkdGg6IG1heCA+IE51bWJlcihtYXhXaWR0aCkgPyBtYXhXaWR0aCA6IG1heCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSU5GTzogVG8gc2V0IGJvdW5kcyBpbiBgbG9jayBhc3BlY3QgcmF0aW8gd2l0aCBib3VuZHNgIGNhc2UuIFNlZSBhbHNvIHRoYXQgc3RvcnkuXG4gICAgICAgICAgICAgICAgaWYgKGhhc1JpZ2h0IHx8ICh0aGlzLnByb3BzLmxvY2tBc3BlY3RSYXRpbyAmJiAhaGFzTGVmdCAmJiAhaGFzVG9wKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gb2Zmc2V0V2lkdGggKyAoYm91bmRhcnlMZWZ0IC0gc2VsZkxlZnQpIC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBtYXhXaWR0aDogbWF4ID4gTnVtYmVyKG1heFdpZHRoKSA/IG1heFdpZHRoIDogbWF4IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGhhc1RvcCB8fCBoYXNMZWZ0KSAmJiB0aGlzLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gKHNlbGZUb3AgLSBib3VuZGFyeVRvcCkgLyBzY2FsZSArIHRoaXMucmVzaXphYmxlLnNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodDogbWF4ID4gTnVtYmVyKG1heEhlaWdodCkgPyBtYXhIZWlnaHQgOiBtYXgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJTkZPOiBUbyBzZXQgYm91bmRzIGluIGBsb2NrIGFzcGVjdCByYXRpbyB3aXRoIGJvdW5kc2AgY2FzZS4gU2VlIGFsc28gdGhhdCBzdG9yeS5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQm90dG9tIHx8ICh0aGlzLnByb3BzLmxvY2tBc3BlY3RSYXRpbyAmJiAhaGFzVG9wICYmICFoYXNMZWZ0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gb2Zmc2V0SGVpZ2h0ICsgKGJvdW5kYXJ5VG9wIC0gc2VsZlRvcCkgLyBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IG1heCA+IE51bWJlcihtYXhIZWlnaHQpID8gbWF4SGVpZ2h0IDogbWF4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogdGhpcy5wcm9wcy5tYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IHRoaXMucHJvcHMubWF4SGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25SZXNpemVTdGFydCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZVN0YXJ0KGUsIGRpciwgZWxlbWVudFJlZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbiAoZSwgZGlyZWN0aW9uLCBlbGVtZW50UmVmLCBkZWx0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBJTkZPOiBBcHBseSB4IGFuZCB5IHBvc2l0aW9uIGFkanVzdG1lbnRzIGNhdXNlZCBieSByZXNpemluZyB0byBkcmFnZ2FibGVcbiAgICAgICAgdmFyIG5ld1BvcyA9IHsgeDogdGhpcy5vcmlnaW5hbFBvc2l0aW9uLngsIHk6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi55IH07XG4gICAgICAgIHZhciBsZWZ0ID0gLWRlbHRhLndpZHRoO1xuICAgICAgICB2YXIgdG9wID0gLWRlbHRhLmhlaWdodDtcbiAgICAgICAgdmFyIGRpcmVjdGlvbnMgPSBbXCJ0b3BcIiwgXCJsZWZ0XCIsIFwidG9wTGVmdFwiLCBcImJvdHRvbUxlZnRcIiwgXCJ0b3BSaWdodFwiXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbnMuaW5jbHVkZXMoZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJib3R0b21MZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICBuZXdQb3MueCArPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcInRvcFJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBuZXdQb3MueSArPSB0b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdQb3MueCArPSBsZWZ0O1xuICAgICAgICAgICAgICAgIG5ld1Bvcy55ICs9IHRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhZ2dhYmxlU3RhdGUgPSB0aGlzLmRyYWdnYWJsZS5zdGF0ZTtcbiAgICAgICAgaWYgKG5ld1Bvcy54ICE9PSBkcmFnZ2FibGVTdGF0ZS54IHx8IG5ld1Bvcy55ICE9PSBkcmFnZ2FibGVTdGF0ZS55KSB7XG4gICAgICAgICAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdnYWJsZS5zZXRTdGF0ZShuZXdQb3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVPZmZzZXRGcm9tUGFyZW50KCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldEZyb21QYXJlbnQ7XG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpLnggKyBvZmZzZXQubGVmdDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldERyYWdnYWJsZVBvc2l0aW9uKCkueSArIG9mZnNldC50b3A7XG4gICAgICAgIHRoaXMucmVzaXppbmdQb3NpdGlvbiA9IHsgeDogeCwgeTogeSB9O1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMub25SZXNpemUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucHJvcHMub25SZXNpemUoZSwgZGlyZWN0aW9uLCBlbGVtZW50UmVmLCBkZWx0YSwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5vblJlc2l6ZVN0b3AgPSBmdW5jdGlvbiAoZSwgZGlyZWN0aW9uLCBlbGVtZW50UmVmLCBkZWx0YSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHJlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0TWF4U2l6ZXNGcm9tUHJvcHMoKSwgbWF4V2lkdGggPSBfYS5tYXhXaWR0aCwgbWF4SGVpZ2h0ID0gX2EubWF4SGVpZ2h0O1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCB9KTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25SZXNpemVTdG9wKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVzaXplU3RvcChlLCBkaXJlY3Rpb24sIGVsZW1lbnRSZWYsIGRlbHRhLCB0aGlzLnJlc2l6aW5nUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlc2l6YWJsZS51cGRhdGVTaXplKHsgd2lkdGg6IHNpemUud2lkdGgsIGhlaWdodDogc2l6ZS5oZWlnaHQgfSk7XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlLnNldFN0YXRlKHBvc2l0aW9uKTtcbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUudXBkYXRlT2Zmc2V0RnJvbVBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wcm9wcy5zY2FsZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcy5nZXRTZWxmRWxlbWVudCgpO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBzZWxmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHBhcmVudExlZnQgPSBwYXJlbnRSZWN0LmxlZnQ7XG4gICAgICAgIHZhciBwYXJlbnRUb3AgPSBwYXJlbnRSZWN0LnRvcDtcbiAgICAgICAgdmFyIHNlbGZSZWN0ID0gc2VsZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gcGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5vZmZzZXRGcm9tUGFyZW50ID0ge1xuICAgICAgICAgICAgbGVmdDogc2VsZlJlY3QubGVmdCAtIHBhcmVudExlZnQgKyBzY3JvbGxMZWZ0IC0gcG9zaXRpb24ueCAqIHNjYWxlLFxuICAgICAgICAgICAgdG9wOiBzZWxmUmVjdC50b3AgLSBwYXJlbnRUb3AgKyBzY3JvbGxUb3AgLSBwb3NpdGlvbi55ICogc2NhbGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGlzYWJsZURyYWdnaW5nID0gX2EuZGlzYWJsZURyYWdnaW5nLCBzdHlsZSA9IF9hLnN0eWxlLCBkcmFnSGFuZGxlQ2xhc3NOYW1lID0gX2EuZHJhZ0hhbmRsZUNsYXNzTmFtZSwgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgb25Nb3VzZURvd24gPSBfYS5vbk1vdXNlRG93biwgb25Nb3VzZVVwID0gX2Eub25Nb3VzZVVwLCBkcmFnQXhpcyA9IF9hLmRyYWdBeGlzLCBkcmFnR3JpZCA9IF9hLmRyYWdHcmlkLCBib3VuZHMgPSBfYS5ib3VuZHMsIGVuYWJsZVVzZXJTZWxlY3RIYWNrID0gX2EuZW5hYmxlVXNlclNlbGVjdEhhY2ssIGNhbmNlbCA9IF9hLmNhbmNlbCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgb25SZXNpemVTdGFydCA9IF9hLm9uUmVzaXplU3RhcnQsIG9uUmVzaXplID0gX2Eub25SZXNpemUsIG9uUmVzaXplU3RvcCA9IF9hLm9uUmVzaXplU3RvcCwgb25EcmFnU3RhcnQgPSBfYS5vbkRyYWdTdGFydCwgb25EcmFnID0gX2Eub25EcmFnLCBvbkRyYWdTdG9wID0gX2Eub25EcmFnU3RvcCwgcmVzaXplSGFuZGxlU3R5bGVzID0gX2EucmVzaXplSGFuZGxlU3R5bGVzLCByZXNpemVIYW5kbGVDbGFzc2VzID0gX2EucmVzaXplSGFuZGxlQ2xhc3NlcywgcmVzaXplSGFuZGxlQ29tcG9uZW50ID0gX2EucmVzaXplSGFuZGxlQ29tcG9uZW50LCBlbmFibGVSZXNpemluZyA9IF9hLmVuYWJsZVJlc2l6aW5nLCByZXNpemVHcmlkID0gX2EucmVzaXplR3JpZCwgcmVzaXplSGFuZGxlV3JhcHBlckNsYXNzID0gX2EucmVzaXplSGFuZGxlV3JhcHBlckNsYXNzLCByZXNpemVIYW5kbGVXcmFwcGVyU3R5bGUgPSBfYS5yZXNpemVIYW5kbGVXcmFwcGVyU3R5bGUsIHNjYWxlID0gX2Euc2NhbGUsIGFsbG93QW55Q2xpY2sgPSBfYS5hbGxvd0FueUNsaWNrLCBkcmFnUG9zaXRpb25PZmZzZXQgPSBfYS5kcmFnUG9zaXRpb25PZmZzZXQsIHJlc2l6YWJsZVByb3BzID0gX19yZXN0KF9hLCBbXCJkaXNhYmxlRHJhZ2dpbmdcIiwgXCJzdHlsZVwiLCBcImRyYWdIYW5kbGVDbGFzc05hbWVcIiwgXCJwb3NpdGlvblwiLCBcIm9uTW91c2VEb3duXCIsIFwib25Nb3VzZVVwXCIsIFwiZHJhZ0F4aXNcIiwgXCJkcmFnR3JpZFwiLCBcImJvdW5kc1wiLCBcImVuYWJsZVVzZXJTZWxlY3RIYWNrXCIsIFwiY2FuY2VsXCIsIFwiY2hpbGRyZW5cIiwgXCJvblJlc2l6ZVN0YXJ0XCIsIFwib25SZXNpemVcIiwgXCJvblJlc2l6ZVN0b3BcIiwgXCJvbkRyYWdTdGFydFwiLCBcIm9uRHJhZ1wiLCBcIm9uRHJhZ1N0b3BcIiwgXCJyZXNpemVIYW5kbGVTdHlsZXNcIiwgXCJyZXNpemVIYW5kbGVDbGFzc2VzXCIsIFwicmVzaXplSGFuZGxlQ29tcG9uZW50XCIsIFwiZW5hYmxlUmVzaXppbmdcIiwgXCJyZXNpemVHcmlkXCIsIFwicmVzaXplSGFuZGxlV3JhcHBlckNsYXNzXCIsIFwicmVzaXplSGFuZGxlV3JhcHBlclN0eWxlXCIsIFwic2NhbGVcIiwgXCJhbGxvd0FueUNsaWNrXCIsIFwiZHJhZ1Bvc2l0aW9uT2Zmc2V0XCJdKTtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRoaXMucHJvcHMuZGVmYXVsdCA/IF9fYXNzaWduKHt9LCB0aGlzLnByb3BzLmRlZmF1bHQpIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBSZW1vdmUgdW5rbm93biBwcm9wcywgc2VlIGFsc28gaHR0cHM6Ly9yZWFjdGpzLm9yZy93YXJuaW5ncy91bmtub3duLXByb3AuaHRtbFxuICAgICAgICBkZWxldGUgcmVzaXphYmxlUHJvcHMuZGVmYXVsdDtcbiAgICAgICAgdmFyIGN1cnNvclN0eWxlID0gZGlzYWJsZURyYWdnaW5nIHx8IGRyYWdIYW5kbGVDbGFzc05hbWUgPyB7IGN1cnNvcjogXCJhdXRvXCIgfSA6IHsgY3Vyc29yOiBcIm1vdmVcIiB9O1xuICAgICAgICB2YXIgaW5uZXJTdHlsZSA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXNpemFibGVTdHlsZSksIGN1cnNvclN0eWxlKSwgc3R5bGUpO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLm9mZnNldEZyb21QYXJlbnQsIGxlZnQgPSBfYi5sZWZ0LCB0b3AgPSBfYi50b3A7XG4gICAgICAgIHZhciBkcmFnZ2FibGVQb3NpdGlvbjtcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBkcmFnZ2FibGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NpdGlvbi54IC0gbGVmdCxcbiAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55IC0gdG9wLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJTkZPOiBNYWtlIHVuY29udG9yb2xsZWQgY29tcG9uZW50IHdoZW4gcmVzaXppbmcgdG8gY29udHJvbCBwb3NpdGlvbiBieSBzZXRQb3N0aW9uLlxuICAgICAgICB2YXIgcG9zID0gdGhpcy5zdGF0ZS5yZXNpemluZyA/IHVuZGVmaW5lZCA6IGRyYWdnYWJsZVBvc2l0aW9uO1xuICAgICAgICB2YXIgZHJhZ0F4aXNPclVuZGVmaW5lZCA9IHRoaXMuc3RhdGUucmVzaXppbmcgPyBcImJvdGhcIiA6IGRyYWdBeGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRHJhZ2dhYmxlLCB7IHJlZjogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2FibGUgPSBjO1xuICAgICAgICAgICAgfSwgaGFuZGxlOiBkcmFnSGFuZGxlQ2xhc3NOYW1lID8gXCIuXCIuY29uY2F0KGRyYWdIYW5kbGVDbGFzc05hbWUpIDogdW5kZWZpbmVkLCBkZWZhdWx0UG9zaXRpb246IGRlZmF1bHRWYWx1ZSwgb25Nb3VzZURvd246IG9uTW91c2VEb3duLCBcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIG9uTW91c2VVcDogb25Nb3VzZVVwLCBvblN0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LCBvbkRyYWc6IHRoaXMub25EcmFnLCBvblN0b3A6IHRoaXMub25EcmFnU3RvcCwgYXhpczogZHJhZ0F4aXNPclVuZGVmaW5lZCwgZGlzYWJsZWQ6IGRpc2FibGVEcmFnZ2luZywgZ3JpZDogZHJhZ0dyaWQsIGJvdW5kczogYm91bmRzID8gdGhpcy5zdGF0ZS5ib3VuZHMgOiB1bmRlZmluZWQsIHBvc2l0aW9uOiBwb3MsIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBlbmFibGVVc2VyU2VsZWN0SGFjaywgY2FuY2VsOiBjYW5jZWwsIHNjYWxlOiBzY2FsZSwgYWxsb3dBbnlDbGljazogYWxsb3dBbnlDbGljaywgbm9kZVJlZjogdGhpcy5yZXNpemFibGVFbGVtZW50LCBwb3NpdGlvbk9mZnNldDogZHJhZ1Bvc2l0aW9uT2Zmc2V0IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFJlc2l6YWJsZSwgX19hc3NpZ24oe30sIHJlc2l6YWJsZVByb3BzLCB7IHJlZjogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNpemFibGUgPSBjO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNpemFibGVFbGVtZW50LmN1cnJlbnQgPSBjLnJlc2l6YWJsZTtcbiAgICAgICAgICAgICAgICB9LCBkZWZhdWx0U2l6ZTogZGVmYXVsdFZhbHVlLCBzaXplOiB0aGlzLnByb3BzLnNpemUsIGVuYWJsZTogdHlwZW9mIGVuYWJsZVJlc2l6aW5nID09PSBcImJvb2xlYW5cIiA/IGdldEVuYWJsZVJlc2l6aW5nQnlGbGFnKGVuYWJsZVJlc2l6aW5nKSA6IGVuYWJsZVJlc2l6aW5nLCBvblJlc2l6ZVN0YXJ0OiB0aGlzLm9uUmVzaXplU3RhcnQsIG9uUmVzaXplOiB0aGlzLm9uUmVzaXplLCBvblJlc2l6ZVN0b3A6IHRoaXMub25SZXNpemVTdG9wLCBzdHlsZTogaW5uZXJTdHlsZSwgbWluV2lkdGg6IHRoaXMucHJvcHMubWluV2lkdGgsIG1pbkhlaWdodDogdGhpcy5wcm9wcy5taW5IZWlnaHQsIG1heFdpZHRoOiB0aGlzLnN0YXRlLnJlc2l6aW5nID8gdGhpcy5zdGF0ZS5tYXhXaWR0aCA6IHRoaXMucHJvcHMubWF4V2lkdGgsIG1heEhlaWdodDogdGhpcy5zdGF0ZS5yZXNpemluZyA/IHRoaXMuc3RhdGUubWF4SGVpZ2h0IDogdGhpcy5wcm9wcy5tYXhIZWlnaHQsIGdyaWQ6IHJlc2l6ZUdyaWQsIGhhbmRsZVdyYXBwZXJDbGFzczogcmVzaXplSGFuZGxlV3JhcHBlckNsYXNzLCBoYW5kbGVXcmFwcGVyU3R5bGU6IHJlc2l6ZUhhbmRsZVdyYXBwZXJTdHlsZSwgbG9ja0FzcGVjdFJhdGlvOiB0aGlzLnByb3BzLmxvY2tBc3BlY3RSYXRpbywgbG9ja0FzcGVjdFJhdGlvRXh0cmFXaWR0aDogdGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoLCBsb2NrQXNwZWN0UmF0aW9FeHRyYUhlaWdodDogdGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW9FeHRyYUhlaWdodCwgaGFuZGxlU3R5bGVzOiByZXNpemVIYW5kbGVTdHlsZXMsIGhhbmRsZUNsYXNzZXM6IHJlc2l6ZUhhbmRsZUNsYXNzZXMsIGhhbmRsZUNvbXBvbmVudDogcmVzaXplSGFuZGxlQ29tcG9uZW50LCBzY2FsZTogdGhpcy5wcm9wcy5zY2FsZSB9KSwgY2hpbGRyZW4pKSk7XG4gICAgfTtcbiAgICBSbmQuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBtYXhXaWR0aDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIG1heEhlaWdodDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICBvblJlc2l6ZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIG9uUmVzaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIG9uUmVzaXplU3RvcDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBvbkRyYWc6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgb25EcmFnU3RvcDogZnVuY3Rpb24gKCkgeyB9LFxuICAgIH07XG4gICAgcmV0dXJuIFJuZDtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG5leHBvcnQgeyBSbmQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-rnd/lib/index.js\n");

/***/ })

};
;